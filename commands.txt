# All: https://neovim.io/doc/user/vimindex.html


NETRW:
:find .         - open netrw for file browsing
- :o            - open file for editing
- :e file.x     - define a file and open e buffer for adding contets in it. Must save for it to be created
- :w            - save buffer contents to the file
mt              - toggle mark on target file to copy
mf              - toggle mark on target folder to copy into
mc              - make copy


i               - insert before. toggling moves cursor one character to the left
a               - insert after (apend)
x               - delete character
w               - move cursor to the the first character of the next word.
W               - same as w but considers only whitespaces as a separator between words. An empty line is a white space.
e               - move cursor to the last character of the word and that of the next word in the next step.
E               - same as e but considers only whitespaces as a separator between words. An empty line is a white space.
d
D
0
$
^

<S-O>           - insert mode on new line above
<S-I>           - equivalent to $+i to move to the first character of the line and switch to insert mode at the beginning
<S-A>           - equivalent to $+a to move to the last character of the line and switch to insert mode at the end


gg              - go to start of file
<Shift-G>       - go to end of file
z+<Shift-M>     - code fold


:messages       - to see the whole output in the messages window
<C-w>_          - maximize the height of the messages window to take a better look



NEW WINDOW:
:vsplit         - duplicate current buffer in by splitting in half vertically (new buffer right as per opt settings)
:split          - duplicate current buffer in by splitting in half horizontally (new buffer below as per opt settings)
:new|put=execute('map')     - open a new buffer window and fill it with a command's return contents for scrolling through.
                            - :map in this case prints the list of mapped keys. Without new, scrolling though is not available.
:vnew           - open a window with an empty buffer splitting in half vertically (new buffer right as per opt settings)
:new            - open a window with an empty buffer splitting in half horizontally (new buffer bellow as per opt settings)
* you will have a new buffer then, obviously. that buffer becomes a file only if you :w it to the disk.


YANK / PASTE:
v       - enter visual mode
y       - copy (yank) selected text
d       - cut (delete) selected text
p       - paste after the cursor
<S-P>   - paste before the cursor.


<S>-d-f / :NvimTreeOpen     - opens a dir tree structure on the left side
g? (during tree open)       - lists a series of available commands to navigate said tree




Maps (keys are not case sensitive):
<CTRL-j> OR :wincmd j       - jump cursor to buffer window down
<CTRL-k> OR :wincmd k       - jump cursor to buffer window up
<CTRL-h> OR :wincmd h       - jump cursor to buffer window left
<CTRL-l> OR :wincmd l       - jump cursor to buffer window right



General (debug related):
:h deprecated           - lists a series of deprecated functionalities to help with debugging broken config changes
:map                    - list currently mapped keys (variations for different modes only = :nmap, :imap, :vmap)
:verbose map <C-/>      - print details relating only to a particular mapping
/ & key combination     - shows in the actual internal mapping of a combination in the message window.
                          <C-/> => <C-_> and gets displayed as ^_ in windows. ^ represents CTRL.

LSP:
:LspInfo (on an opened buffer)          - for debugging if an LSP client attached to the installed LSP server
:=vim.lsp.get_client_by_id(id).server_capabilities
                                        - see capabilities of lsp, providing the id from LspInfo command
On an opened file type (based on extension).
:checkhealth lsp        -- check if the lsp clients are attached
:LspInfo                -- check if the lsp client for that type has been attached successfully
:LspLog + <S-g>         -- see the logs for the lsp attachment, to check if any errors occurred, despite the client being attached


PACKAGE MANAGERS:
:Lazy                                   - opens a graphical status window
:h mason-commands                       - help buffer for the mason app
:Mason                                  - opens a graphical status window
:MasonUpdate                            - updates all managed registries
:MasonInstall <package> ...             - installs/re-installs the provided packages
:MasonUninstall <package> ...           - uninstalls the provided packages
:MasonUninstallAll                      - uninstalls all packages
:MasonLog                               - opens the mason.nvim log file in a new tab window

Finding:
<S-#> (while hovering in normal mode)       - iterate over all instances of the sequence of chars within the file

MULTIPLE LINES EDITING:

To comment out blocks in vim:
- press Esc (to leave editing or other mode)
- hit ctrl+v (visual block mode)
- use the ↑/↓ arrow keys to select lines you want (it won't highlight everything - it's OK!)
- Shift+i (capital I)
- insert the text you want, e.g. %
- press EscEsc

To uncomment blocks in vim:
- press Esc (to leave editing or other mode)
- hit ctrl+v (visual block mode)
- use the ↑/↓ arrow keys to select the lines to uncomment.

If you want to select multiple characters, use one or combine these methods:

- use the left/right arrow keys to select more text
- to select chunks of text use shift + ←/→ arrow key
- you can repeatedly push the delete keys below, like a regular delete button
- press d or x to delete characters, repeatedly if necessary


TERMINAL EMULATION:
:terminal                                   - opens a shell without previous output
:terminal python %                          - runs command in terminal without subprocess lagging io operations: https://vi.stackexchange.com/a/29347
:exec "!python '.shellescape('%')<CR>")     - runs command in interactive shell but slow to update: https://vi.stackexchange.com/a/29347
<C-Z> / :shell                              - spawns a new shell from vim
:!sh, :!bash, :!zsh                         - same effect as :shell
:source %                                   - run current lua commands, provided that the buffer was saved on disk under a file name
:lua print('lala')                          - execute command line lua code and get output in the messaging area (also called the command output area)
:lua vim.o.cmdheight=5                      - increase the command line area
:luafile %                                  - run currently opened (in window buffer) lua code
:messages                                   - expand the messaging area if the output is cut off
:messages clear                             - flush the messaging area (needed as it stores all of the historic output)
vim.o.cmdheight = 3                         - more space for messages
vim.o.cmdheight = 0                         - Neovim 0.9+: auto-hide when not used


BUFFERS:
:ls                 - shows a list of buffers that are currently known to the editor
:buffers            – same as :ls
:ls!                – also shows unlisted buffers
:bn / :bp           – next / previous buffer
:b3                 - example, switch to buffer 3 from the listed buffers

Common flags:
% → current buffer
# → alternate buffer (the previous one)
a → active (loaded and displayed)
h → hidden (loaded but not currently shown)
+ → modified (unsaved changes)
= → read-only

Closing the buffers / windows:
:bd / nvim_buf_delete       - remove buffer, may reuse window
:bwipeout                   - remove buffer **and** all marks, undo history, etc.
:q / win_close              - close the window, buffer may still exist


WINDOW RESIZING:
<C-w> =     - make all windows (almost) equally high and wide
<C-w> <     - make currently selected window thinner
<C-w> >     - make currently selected window wider
<C-w> -     - make currently selected window shorter
<C-w> +     - make currently selected window longer
Note: Basically 


KILLING A PROCESS:
:q      - only closes the window while the terminal buffer (for example) still exists and so does the running process
:bd     - neovim terminates the terminal job and the running process receives a SIGHUP (hang up), not SIGKILL (kill forcefully)
:bd!    - same as :bd but this one triggers a force terminate
<C-c>   - sends a SIGINT which is the safest shutdown

Important signal detail (for accuracy)
- Neovim does not send SIGKILL
- It sends SIGHUP
- SIGKILL cannot be intercepted; SIGHUP can, but most programs (including Python) exit anyway


These are **Unix signals** — ways the OS tells a process that *something happened*.
The key differences are **who sends them**, **what they mean**, and **whether the process can react**.

---

## SIGINT — *Interrupt*

**Signal number:** 2
**Typical source:** Keyboard (`Ctrl-C`)

### What it means

> “Please stop what you’re doing.”

### Behavior

* Can be **caught**, **handled**, or **ignored**
* Default action: **terminate the process**
* Programs often use it for **graceful shutdown**

### Common examples

* Pressing `Ctrl-C` in a terminal
* Stopping a running Python script

### Python behavior

* Raises `KeyboardInterrupt`
* Lets you clean up with `try/except` or signal handlers

---

## SIGHUP — *Hang Up*

**Signal number:** 1
**Typical source:** Terminal closed / parent process exited

### What it means

> “Your controlling terminal disappeared.”

### Behavior

* Can be **caught**, **handled**, or **ignored**
* Default action: **terminate the process**
* Traditionally used to **reload configuration**

### Common examples

* Closing a terminal
* Deleting a Neovim terminal buffer
* Logging out of an SSH session

### Modern usage

* Daemons often treat SIGHUP as “reload config”
* Tools like `nohup` ignore it

---

## SIGKILL — *Kill (forceful)*

**Signal number:** 9
**Typical source:** `kill -9`

### What it means

> “Stop. Now.”

### Behavior

* **Cannot** be caught, handled, or ignored
* Kernel **immediately terminates** the process
* No cleanup, no `finally`, no atexit handlers

### Common examples

* Killing a frozen or misbehaving process
* Last resort only

---

## Comparison table

| Signal      | Can be handled? | Can be ignored? | Cleanup allowed? | Typical use               |
| ----------- | --------------- | --------------- | ---------------- | ------------------------- |
| **SIGINT**  | ✅               | ✅               | ✅                | User interrupt (`Ctrl-C`) |
| **SIGHUP**  | ✅               | ✅               | ✅                | Terminal closed / reload  |
| **SIGKILL** | ❌               | ❌               | ❌                | Emergency stop            |

---

## Practical advice

* **Use SIGINT first** → clean shutdown
* **Use SIGHUP** → session-related stop or reload
* **Use SIGKILL only if nothing else works**

### Kill command examples

```bash
kill -SIGINT <pid>   # same as Ctrl-C
kill -SIGHUP <pid>
kill -9 <pid>        # SIGKILL
```

---

## Neovim context (tying it back)

* `Ctrl-C` in a `:terminal` → **SIGINT**
* Deleting the terminal buffer → **SIGHUP**
* Neovim **never sends SIGKILL automatically**

If you want, I can explain **SIGTERM** too — it sits right between SIGINT and SIGKILL and is very commonly used.
